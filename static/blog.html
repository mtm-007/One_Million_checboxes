<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Building One Million Checkboxes</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
    background: #fff;
    color: #333;
    font-family: "Palatino Linotype", "Book Antiqua", Palatino, Georgia, serif;
    font-size: 18px;
    line-height: 1.7;
    -webkit-font-smoothing: antialiased;
}
nav.blog-nav {
    border-bottom: 1px solid #e8e8e8;
    padding: 12px 0;
}
.blog-nav-inner {
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 30px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
.blog-nav-home {
    font-size: 17px;
    font-weight: bold;
    color: #000;
    text-decoration: none;
}
.blog-nav-links { display: flex; gap: 24px; }
.blog-nav-links a { font-size: 14px; color: #555; text-decoration: none; }
.blog-nav-links a:hover { color: #000; }
.blog-container {
    max-width: 1100px;
    margin: 0 auto;
    padding: 36px 30px 100px;
    display: flex;
    gap: 56px;
    align-items: flex-start;
}
.blog-sidebar {
    width: 200px;
    flex-shrink: 0;
    position: sticky;
    top: 24px;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 13px;
    line-height: 1.5;
}
.blog-sidebar-title {
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.07em;
    color: #bbb;
    margin-bottom: 10px;
}
.blog-sidebar ul { list-style: none; padding: 0; }
.blog-sidebar > ul > li { margin-bottom: 8px; }
.blog-sidebar ul ul { padding-left: 12px; margin-top: 4px; }
.blog-sidebar ul ul li { margin-bottom: 4px; }
.blog-sidebar a { color: #666; text-decoration: none; display: block; }
.blog-sidebar a:hover { color: #000; }
.blog-article-col { flex: 1; min-width: 0; }
.blog-post-header { margin-bottom: 32px; }
.blog-post-header h1 {
    font-family: "Palatino Linotype", "Book Antiqua", Palatino, Georgia, serif;
    font-size: 38px;
    font-weight: bold;
    color: #111;
    line-height: 1.2;
    letter-spacing: -0.01em;
    margin-bottom: 8px;
}
.blog-post-meta {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #aaa;
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
}
.meta-sep { color: #ddd; }
.meta-tag {
    background: #f5f5f5;
    border-radius: 3px;
    padding: 1px 7px;
    color: #888;
    font-size: 11px;
}
.blog-article {
    font-family: "Palatino Linotype", "Book Antiqua", Palatino, Georgia, serif;
    font-size: 18px;
    line-height: 1.7;
    color: #333;
}
.blog-article p { margin-bottom: 20px; }
.blog-article > p:first-child { font-size: 19px; color: #222; }
.blog-article h2 {
    font-family: "Palatino Linotype", "Book Antiqua", Palatino, Georgia, serif;
    font-size: 28px; font-weight: bold; color: #111;
    margin: 48px 0 14px; line-height: 1.3;
}
.blog-article h3 {
    font-family: "Palatino Linotype", "Book Antiqua", Palatino, Georgia, serif;
    font-size: 22px; font-weight: bold; color: #222;
    margin: 36px 0 12px;
}
.blog-article h4 {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 15px; font-weight: bold; color: #333; margin: 28px 0 8px;
}
.blog-article strong { color: #111; }
.blog-article em { font-style: italic; }
.blog-article a { color: #2a7ae2; text-decoration: none; }
.blog-article a:hover { text-decoration: underline; }
.blog-article code {
    font-family: Menlo, Monaco, "Courier New", monospace;
    font-size: 14px; background: #f5f5f5; border: 1px solid #ddd;
    color: #c7254e; padding: 1px 5px; border-radius: 3px;
}
.blog-article pre {
    background: #f8f8f8; border: 1px solid #ddd; border-radius: 3px;
    padding: 14px 18px; overflow-x: auto; margin: 20px 0; line-height: 1.55;
}
.blog-article pre code {
    background: none; border: none; padding: 0;
    color: #333; font-size: 13.5px; white-space: pre;
}
.blog-article blockquote {
    border-left: 4px solid #ddd; padding: 4px 0 4px 18px;
    margin: 24px 0; color: #666; font-style: italic;
}
.blog-article hr { border: none; border-top: 1px solid #eee; margin: 40px 0; }
.blog-article ul { list-style: disc; padding-left: 28px; margin-bottom: 20px; }
.blog-article ol { list-style: decimal; padding-left: 28px; margin-bottom: 20px; }
.blog-article li { margin-bottom: 6px; color: #333; }
.blog-footer {
    margin-top: 60px; padding-top: 24px; border-top: 1px solid #eee;
    display: flex; gap: 10px; flex-wrap: wrap;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 13px;
}
.blog-footer a {
    color: #555; text-decoration: none; padding: 5px 12px;
    border: 1px solid #ddd; border-radius: 3px; background: #fafafa;
}
.blog-footer a:hover { color: #000; border-color: #aaa; background: #f0f0f0; }
@media (max-width: 780px) {
    .blog-container { flex-direction: column; gap: 0; padding: 24px 20px 80px; }
    .blog-sidebar { display: none; }
    .blog-post-header h1 { font-size: 28px; }
    .blog-article { font-size: 17px; }
    .blog-article h2 { font-size: 23px; }
}
</style>
</head>
<body>

<nav class="blog-nav">
  <div class="blog-nav-inner">
    <a href="/" class="blog-nav-home">One Million Checkboxes üßÄ</a>
    <div class="blog-nav-links">
      <a href="/visitors">Visitors</a>
      <a href="https://github.com/mtm-007/one-million-checkboxes" target="_blank">GitHub ‚Üó</a>
    </div>
  </div>
</nav>

<div class="blog-container">
  <aside class="blog-sidebar">
    <div class="blog-sidebar-title">Table of Contents</div>
    <ul><li><a href="#the-idea">The Idea</a></li>
<li><a href="#the-stack">The Stack</a></li>
<li><a href="#the-architecture">The Architecture</a></li>
<li style="padding-left:12px;"><a href="#the-bitmap-trick">The Bitmap Trick</a></li>
<li style="padding-left:12px;"><a href="#real-time-updates-without-websockets">Real-Time Updates Without WebSockets</a></li>
<li style="padding-left:12px;"><a href="#system-design-overview">System Design Overview</a></li>
<li><a href="#building-the-visitor-analytics-dashboard">Building the Visitor Analytics Dashboard</a></li>
<li style="padding-left:12px;"><a href="#visitor-tracking-flow">Visitor Tracking Flow</a></li>
<li style="padding-left:12px;"><a href="#session-tracking">Session Tracking</a></li>
<li><a href="#the-page-cache-layer">The Page Cache Layer</a></li>
<li><a href="#debugging-the-github-referrer-problem">Debugging the GitHub Referrer Problem</a></li>
<li><a href="#takeaways">Takeaways</a></li>
</ul>
  </aside>

  <div class="blog-article-col">
    <header class="blog-post-header">
      <h1>Building One Million Checkboxes</h1>
      <div class="blog-post-meta">
        Feb 2025
        <span class="meta-sep">¬∑</span>
        8 min read
        <span class="meta-sep">¬∑</span>
        <span class="meta-tag">FastHTML</span>
        <span class="meta-tag">Redis</span>
        <span class="meta-tag">Modal</span>
      </div>
    </header>

    <div class="blog-article"><h1 id="building-one-million-checkboxes-a-real-time-collaborative-app-with-fasthtml-redis-modal">Building One Million Checkboxes: A Real-Time Collaborative App with FastHTML, Redis &amp; Modal</h1>
<p>A few weeks ago I built and deployed a real-time collaborative web app where anyone in the world can click any of one million checkboxes ‚Äî and everyone else sees it update instantly. Along the way I learned a lot about architecture, serverless deployment, visitor analytics, and the surprisingly tricky world of referrer tracking. This post walks through the whole journey.</p>
<hr />
<h2 id="the-idea">The Idea</h2>
<p>The concept is simple: one million checkboxes, shared state, live updates. Click one and every connected browser reflects the change in under a second. It sounds trivial until you think about the data ‚Äî naively storing a million booleans as a JSON list costs around 8MB in memory. Multiply that by every read and write and it gets expensive fast.</p>
<p>The app is live at <a href="https://mtm-007--fasthtml-checkboxes-web.modal.run/">mtm-007--fasthtml-checkboxes-web.modal.run</a> if you want to try it before reading further.</p>
<hr />
<h2 id="the-stack">The Stack</h2>
<p>I chose four tools that worked together cleanly:</p>
<p><strong>FastHTML</strong> ‚Äî a Pythonic web framework that lets you build full-stack apps without leaving Python. No Jinja templates, no separate frontend build step. Components are just Python functions.</p>
<p><strong>HTMX</strong> ‚Äî lightweight JavaScript that handles interactivity through HTML attributes. Polling, lazy loading, out-of-band swaps ‚Äî all without writing a single line of custom JS for the core UI.</p>
<p><strong>Redis</strong> ‚Äî the backbone of the whole thing. Not just for caching but as the primary data store for checkboxes, visitor data, geolocation cache, and page cache.</p>
<p><strong>Modal</strong> ‚Äî serverless hosting with auto-scaling and persistent volumes. CI/CD with GitHub Actions deploys straight to Modal on every push.</p>
<hr />
<h2 id="the-architecture">The Architecture</h2>
<h3 id="the-bitmap-trick">The Bitmap Trick</h3>
<p>The key insight that made this feasible is Redis bitmaps. Instead of storing a million booleans as a list or JSON, Redis lets you address individual bits inside a string. One million bits = <strong>125KB</strong>. That's it. Compare that to 8MB for a JSON list ‚Äî a 64x reduction.</p>
<pre><code>SETBIT checkboxes_bitmap 42 1   ‚Üí check box #42
GETBIT checkboxes_bitmap 42     ‚Üí read box #42
BITCOUNT checkboxes_bitmap      ‚Üí count all checked boxes
</code></pre>
<p>Every toggle is a single Redis command. Every read is a single Redis command. The entire state of one million checkboxes fits in a single Redis key.</p>
<h3 id="real-time-updates-without-websockets">Real-Time Updates Without WebSockets</h3>
<p>Rather than setting up WebSockets, I used HTMX polling. Every browser polls <code>/diffs/{client_id}</code> every 500ms. The server maintains a diff queue per client ‚Äî when any checkbox is toggled, that change gets added to every other client's queue. On the next poll, the client gets back just the changed checkboxes and updates them in place.</p>
<p>The flow looks like this:</p>
<ol>
<li>User clicks checkbox #42</li>
<li>Browser POSTs to <code>/toggle/42/{client_id}</code></li>
<li>Server runs <code>GETBIT</code>, then <code>SETBIT</code> on the Redis bitmap</li>
<li>Server adds <code>#42</code> to every other client's diff queue</li>
<li>Server runs <code>BITCOUNT</code> and returns updated stats to the clicking browser</li>
<li>Other browsers hit <code>/diffs/{client_id}</code> on their next 500ms poll</li>
<li>Server returns the queued diff, browsers update checkbox #42</li>
</ol>
<p>This approach trades some latency (up to 500ms) for simplicity. No WebSocket infrastructure, no connection management, no reconnection logic.</p>
<h3 id="system-design-overview">System Design Overview</h3>
<pre><code>üë• CLIENT LAYER
   Browsers (HTMX + Responsive CSS)
        ‚Üì HTTP/HTMX
üñ•Ô∏è APPLICATION LAYER
   FastHTML Web Server
   ‚îú‚îÄ‚îÄ Routes / Handlers      ‚Üí GETBIT/SETBIT/BITCOUNT on Bitmap
   ‚îú‚îÄ‚îÄ Client Manager         ‚Üí Diff queues per connected client
   ‚îú‚îÄ‚îÄ Geo API Layer          ‚Üí Fallback chain: ipwho.is ‚Üí ipapi.co ‚Üí ip-api.com
   ‚îî‚îÄ‚îÄ Redis Cache Layer      ‚Üí 45s TTL for heavy pages like /visitors

üíæ DATA LAYER (Redis)
   ‚îú‚îÄ‚îÄ Bitmap (125KB)         ‚Üí All 1M checkbox states
   ‚îú‚îÄ‚îÄ Visitor Data           ‚Üí Hash + Sorted Set per IP
   ‚îú‚îÄ‚îÄ Geolocation Cache      ‚Üí Avoids repeat API calls
   ‚îî‚îÄ‚îÄ Page Cache             ‚Üí Pre-computed dashboard HTML

üíø STORAGE LAYER
   Modal Volume               ‚Üí /data/dump.rdb + SQLite for persistence
</code></pre>
<hr />
<h2 id="building-the-visitor-analytics-dashboard">Building the Visitor Analytics Dashboard</h2>
<p>Once the core checkbox functionality was working I wanted to know who was using it. I built a full visitor tracking system that captures:</p>
<ul>
<li>IP address and geolocation (city, country, ISP, ZIP)</li>
<li>Device type and OS (parsed from User-Agent)</li>
<li>Classification: Human, Bot, VPN user, or Relay</li>
<li>Referrer source and type (direct, social, search, referral)</li>
<li>Time spent per session, scroll depth, page views, actions</li>
<li>First and last referrer per visitor</li>
</ul>
<h3 id="visitor-tracking-flow">Visitor Tracking Flow</h3>
<pre><code>New Visitor arrives
      ‚Üì
Extract IP (CF-Connecting-IP header)
      ‚Üì
Check Redis geo cache
      ‚îú‚îÄ‚îÄ Cache hit  ‚Üí use cached geo data
      ‚îî‚îÄ‚îÄ Cache miss ‚Üí try ipwho.is ‚Üí ipapi.co ‚Üí ip-api.com (fallback chain)
                             ‚Üì
                       Save to Redis geo cache
      ‚Üì
Classify visitor (Human / Bot / VPN / Relay)
      ‚Üì
Save/update visitor:{ip} hash in Redis
      ‚Üì
Add to recent_visitors_sorted (sorted set by timestamp)
      ‚Üì
Increment total_visitors_count (if new visitor)
      ‚Üì
Save to SQLite for persistence across Redis restarts
</code></pre>
<h3 id="session-tracking">Session Tracking</h3>
<p>Beyond just recording visits, I track how long people actually engage. A JavaScript tracker sends heartbeats every 10 seconds while the page is open, and fires a final <code>session-end</code> beacon on <code>beforeunload</code> using <code>navigator.sendBeacon</code> so it doesn't get cancelled when the tab closes.</p>
<hr />
<h2 id="the-page-cache-layer">The Page Cache Layer</h2>
<pre><code class="language-python">cache_key = f&quot;cache:visitors:{offset}:{limit}:{days}&quot;
cached = await redis.get(cache_key)
if cached:
    return json.loads(cached), &quot;cache-hit&quot;

await redis.set(cache_key, json.dumps(result), ex=45)
return result, &quot;cache-miss&quot;
</code></pre>
<hr />
<h2 id="debugging-the-github-referrer-problem">Debugging the GitHub Referrer Problem</h2>
<p>The root cause: <strong>GitHub renders READMEs inside an iframe with <code>referrerpolicy="no-referrer"</code></strong>.</p>
<pre><code class="language-python">referrer = request.headers.get('referer', '')
if not referrer and request.query_params.get('utm_source') == 'github':
    referrer = 'https://github.com'
</code></pre>
<hr />
<h2 id="takeaways">Takeaways</h2>
<p>The <strong>bitmap trick</strong> is genuinely useful. 125KB vs 8MB is not a marginal improvement.</p>
<p><strong>UTM parameters are not optional</strong> if you care about referrer attribution.</p>
<p><strong>Modal + FastHTML is a genuinely fast way to ship Python web apps.</strong></p>
<p>Give the checkboxes a click. Someone on the other side of the world will see it.</p></div>

    <footer class="blog-footer">
      <a href="/visitors">‚Üê Back to Visitors</a>
      <a href="/">‚Üê Back to Checkboxes</a>
      <a href="https://github.com/mtm-007/one-million-checkboxes" target="_blank">View Source ‚Üó</a>
    </footer>
  </div>
</div>
<script>
    const tracker = {
        startTime: Date.now(), lastHeartbeat: Date.now(), scrollDepth: 0,
        initialized: false,
    
        init() {
            if (this.initialized) return;
            this.initialized = true;
    
            this.sendHeartbeat();
            setInterval(() => { this.sendHeartbeat(); }, 10000);
    
            let scrollTimer;
            window.addEventListener('scroll', () => {
                clearTimeout(scrollTimer);
                scrollTimer = setTimeout(() => {
                    const depth = Math.round((window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100);
                    this.scrollDepth = Math.max(this.scrollDepth, isNaN(depth) ? 0 : depth);
                    fetch('/track-scroll', { method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({depth: this.scrollDepth})
                    }).catch(() => {});
                }, 500);
            });
    
            window.addEventListener('beforeunload', () => { this.endSession(); });
            window.addEventListener('pagehide', () => { this.endSession(); });
        },
        // ‚úÖ add this method
        logAction() {
            this.actionCount = (this.actionCount || 0) + 1;
            fetch('/heartbeat', { method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ duration: (Date.now() - this.startTime) / 1000, 
                                    actions: this.actionCount,
                                    timestamp: Date.now() }), keepalive: true
            }).catch(() => {});
        },
    
        sendHeartbeat() {
            const duration = (Date.now() - this.startTime) / 1000;
            fetch('/heartbeat', { method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ duration, actions: this.actionCount || 0, timestamp: Date.now() }), keepalive: true
            }).catch(() => {});
            this.lastHeartbeat = Date.now();
        },
    
        endSession() {
            const duration = (Date.now() - this.startTime) / 1000;
            const data = { duration, scrollDepth: this.scrollDepth, timestamp: Date.now(), source: "blog" };
            if (navigator.sendBeacon) {
                navigator.sendBeacon('/session-end', new Blob([JSON.stringify(data)], {type: 'application/json'}));
            } else {
                fetch('/session-end', { method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data), keepalive: true }).catch(() => {});
            }
        }
    };
    
    // ‚úÖ visibilitychange is OUTSIDE init() so it always fires
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            tracker.init();  // start tracking if not already started
            fetch('/track-blog-view', { method: 'POST', keepalive: true }).catch(() => {});
            tracker.sendHeartbeat();
        } else {
            tracker.endSession();
        }
    });
    
    tracker.init(); // also init on full page load
</script>
</body>
</html>